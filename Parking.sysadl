Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } dimension PriceDimension dimension ColorDimension unit Real { dimension = PriceDimension } unit Red { dimension = ColorDimension } unit Green { dimension = ColorDimension } unit Blue { dimension = ColorDimension } datatype Vehicle { attributes : driver : String ; licensePlate : String ; } datatype Tickect { attributes : entranceTime : DateTime ; validateTime : DateTime ; barCode : String ; helpText : String ; exitTime : DateTime ; vehicle : Vehicle ; } datatype FiscalNote { attributes : ticket : Tickect ; costPrice : Price ; payedPrice : Price ; adress : String ; paymentType : PaymentType ; } value type DateTime { } value type Price { unit = Real dimension = PriceDimension } value type Color { dimension = ColorDimension } value type RedColor extends Color { unit = Red dimension = ColorDimension } value type GreenColor extends Color { unit = Green dimension = ColorDimension } value type BlueColor extends Color { unit = Blue dimension = ColorDimension } enum Command { ON , OFF } enum PaymentType { DEBIT , CREDIT , PIX , CASH , APP } enum TickecyStatus { VALIDATED , NON_VALIDATED } datatype Spot { attributes : id : Int ; occupied : Boolean ; isPreferential : Boolean ; } datatype LED { attributes : id : Int ; color : Color ; } datatype Dataset { attributes : ticket : Tickect ; } } Requirement VerPrecosRF ( 1.1 ) { text = "\"O sistema deverá fornecer na entrada a visualização dos valores do estacionamento pelo tempo de permanência.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement VisualizarCapacidadeRF ( 1.3 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de visualizar a disponibilidade de vagas do estacionamento na entrada.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement CalcularTaxaRF ( 1.6 ) { text = "\"O sistema deverá calcular a taxa de estacionamento do veículo no momento de pagamento de ticket.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF.RealizarPagamentoRF ; } Requirement EmitirReciboRF ( 1.7 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de emitir recibo de pagamento.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF.RealizarPagamentoRF ; } Requirement ChaveMestreRF ( 1.9 ) { text = "\"O sistema deverá fornecer para o operador a capacidade de liberar cancela com cartão mestre.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement Configuracoes ( 1.10 ) { text = "\"O sistema deverá fornecer para o administrador a capacidade de definir configurações sobre o estacionamento.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement DetectarOcupacaoRF ( 1.11 ) { text = "\"O sistema deverá detectar a ocupação de uma vaga automaticamente.\"" derive VisualizarCapacidadeRF ; } Requirement GerarRelatorioRF ( 1.12 ) { text = "\"O sistema deve ser capaz de gerar relatórios de uso, incluindo estatísticas de ocupação, horários de pico e receitas.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement SistemaEstacionamentoRequisitos ( 0 ) { text = "\"O sistema deve satisfazer os requisitos funcionais e não funcionais”." Requirement SistemaEstacionamentoRF ( 1 ) { text = "“O sistema deve ser capaz de gerenciar a entrada e saída de veículos do estacionamento”." Requirement DeixarEstacionamentoRF ( 1.8 ) { text = "\"O sistema deverá abrir cancela de saída automaticamente se o veículo em circunstância estiver com ticket validado.\"" } Requirement RealizarPagamentoRF ( 1.5 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de realizar o pagamento de ticket.\"" } Requirement RegistrarVeiculoRF ( 1.2 ) { text = "\"O sistema deverá registrar o veículo na entrada do estacionamento.\"" Requirement EmitirTicketRF ( 1.4 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de emitir ticket na entrada do estacionamento.\"" } } } Requirement QualidadeRNF ( 2 ) { text = "“O sistema deve satisfazer o desempenho, segurança, conformidade, escalabilidade, usabilidade, tolerância a falhas e disponibilidade”." Requirement DesempenhoRNF ( 2.1 ) { text = "\"O sistema deverá ser capaz de processar uma entrada/saída de veículo em menos de 5  segundos.\"" } Requirement DesempenhoRNF ( 2.2 ) { text = "\"O tempo de espera na fila da entrada/saída não deve exceder 10 minutos, inclusive durante horários de pico.\"" } Requirement DisponibilidadeRNF ( 2.4 ) { text = "\"O sistema de controle de entradas/saídas deverá estar disponível 99% do tempo e haver redundância para caso de falhas.\"" } Requirement SegurancaRNF ( 2.3 ) { text = "\"O sistema deverá ser capaz de garantir a proteção dos dados dos clientes e das transações financeiras.\"" } Requirement EscalabilidadeRNF ( 2.6 ) { text = "\"O sistema deverá ser capaz de escalar horizontalmente para acomodar o aumento na demanda, como durante eventos especiais.\"" } Requirement UsabilidadeRNF ( 2.7 ) { text = "\"O sistema deverá ser fácil de usar para os operadores e clientes, com interface intuitiva.\"" } Requirement ToleranciaRNF ( 2.9 ) { text = "\"O sistema deverá ser projetado para tolerar falhas de hardware ou software sem interrupções significativas no serviço.\"" } Requirement ConformidadeRNF ( 2.10 ) { text = "\"O sistema deverá estar em conformidade com todas as regulamentações locais, estaduais e nacionais relacionadas a estacionamentos pagos, privacidade de dados e segurança.\"" } } } Requirement DisponibilidadeRNF ( 2.5 ) { text = "\"O tempo de inatividade planejado para manutenção não deverá afetar as operações durante o horário de funcionamento do estacionamento.\"" derive SistemaEstacionamentoRequisitos.QualidadeRNF.DisponibilidadeRNF ; } Requirement UsabilidadeRNF ( 2.8 ) { text = "\"Os avisos e instruções devem ser claros e compreensíveis.\"" derive SistemaEstacionamentoRequisitos.QualidadeRNF.UsabilidadeRNF ; } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def CaptureLincesePlateCN { participants : ~ source : LicensePlateOPT ; ~ target : LicensePlateIPT ; flows : String from source to target } connector def EmitPresenceCN { participants : ~ source : SpotIPT ; ~ target : SpotOPT ; flows : Spot from source to target } connector def EmitColorCN { participants : ~ source : LEDOPT ; ~ target : LEDIPT ; flows : LED from source to target } connector def SendStatusTicketCN { participants : ~ sourceTicket : TicketOPT ; ~ targetTicket : TicketIPT ; ~ targetStatus : StatusOPT ; ~ sourceStatus : StatusIPT ; flows : Tickect from sourceTicket to targetTicket Int from targetStatus to sourceStatus } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ target : CommandIPT ; flows : Command from source to target } connector def SendQuantityCN { participants : ~ source : QuantifyOPT ; ~ target : QuantifyIPT ; flows : Int from source to target } connector def SendVehicleCN { participants : ~ source : VehicleOPT ; ~ target : VehicleIPT ; flows : Vehicle from source to target } connector def SendStatusCN { participants : ~ source : StatusOPT ; ~ target : StatusIPT ; flows : Int from source to target } connector def SendTicketCN { participants : ~ target : TicketIPT ; ~ source : TicketOPT ; flows : Tickect from source to target } connector def SendFiscalNoteCN { participants : ~ target : FiscalNoteIPT ; ~ source : FiscalNoteOPT ; flows : FiscalNote from source to target } connector def SendPaymentCN { participants : ~ target : PaymentMadeIPT ; ~ source : PaymentMadeOPT ; flows : Boolean from source to target } } package ParkingSystemComponents { import SysADL.types ; import ParkingSystemConnectors ; import ParkingSystemPorts ;
	component def ParkingSystem {  configuration { components :             ei : ExitInterfaceCP { using ports : ticketRead : TicketOPT ; code : CodeIPT ; } em : ExitMonitorCP { using ports : plate : LicensePlateIPT ; ticketProcessed : TicketOPT ; } c1 : CameraCP { using ports : detected : LicensePlateOPT ; } rp : ReceiptPrinterCP { using ports : fiscalNote : FiscalNoteIPT ; } pc : PaymentControllerCP { using ports : voucher : FiscalNoteOPT ; ticketRecived : TicketIPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; } pi : PaymentInterfaceCP { using ports : mode : PaymentMadeOPT ; ticket : TicketOPT ; }  tc : TicketControllerCP { using ports : newTicket : TicketOPT ; newVehicle : VehicleIPT ; } gt : GateCP { using ports : state : CommandIPT ; } mk : MasterKeyCP { using ports : gate : CommandOPT ; key : CodeIPT ; } pc : ParkingControllerCP { using ports : gate : CommandOPT ; ticket : StatusTicketCPT ; } ei : EntranceInterfaceCP { using ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; } pi : ParkingInterfaceCP { using ports : quantify : QuantifyIPT ; } ps : PresenceSensorCP { using ports : presence : SpotOPT ; } LEDCP : LEDCP { using ports : stt2 : LEDIPT ; } SpotControllerCP : SpotControllerCP { using ports : vacancies : QuantifyOPT ; led : LEDOPT ; spot : SpotIPT ; } connectors : fn : SendFiscalNoteCN bindings voucher = fiscalNote ; cip : CaptureLincesePlateCN bindings detected = plate ; p1 : SendPaymentCN bindings mode = payment ; t5 : SendTicketCN bindings ticket = ticketRecived ; c2 : SendCommandCN bindings gate = state ; v1 : SendVehicleCN bindings driver = newVehicle ; ep : EmitPresenceCN bindings presence = spot ; qtd : SendQuantityCN bindings vacancies = quantify ; ec : EmitColorCN bindings led = stt2 ; } } boundary
	component def ExitInterfaceCP { ports : ticket : TicketOPT ; code : CodeIPT ; }
	component def CameraCP { ports :  detected : LicensePlateOPT ; }
	component def TicketControllerCP { ports : newTicket : TicketOPT ; vehicle : VehicleIPT ;  }
	component def GateCP { ports : state : CommandIPT ; }
	component def PresenceSensorCP { ports : spot : SpotOPT ; }
	component def LEDCP { ports : state : LEDIPT ; }
	component def SpotControllerCP { ports : vacancies : QuantifyOPT ; led : LEDOPT ;  spot : SpotIPT ; }
	component def ParkingControllerCP { ports :  gate : CommandOPT ;   ticket : StatusTicketCPT ;    configuration { components :  hp : HeartbeaterCP { using ports : status : StatusOPT ; } delegations : status to status } } boundary
	component def EntranceInterfaceCP { ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; requestLicensePlate : RequestLicensePlateCPT ; }
	component def ParkingInterfaceCP { ports :  quantify : QuantifyIPT ; }
	component def ExitMonitorCP { ports : plate : LicensePlateIPT ; ticket : TicketOPT ; }
	component def PaymentControllerCP { ports : voucher : FiscalNoteOPT ; ticket : TicketIPT ; payment : PaymentMadeIPT ; ticketValidated : TicketOPT ; }
	component def PaymentInterfaceCP { ports : mode : PaymentMadeOPT ; ticket : TicketOPT ; }
	component def HeartbeaterCP { ports : status : StatusOPT ; }
	component def MasterKeyCP { ports : gate : CommandOPT ; key : CodeIPT ; }
	component def ReceiptPrinterCP { ports : fiscalNote : FiscalNoteIPT ; } } package ParkingSystemPorts { import SysADL.types ; port def ButtonPressIPT { flow in Boolean } port def FiscalNoteOPT { flow out FiscalNote } port def PriceIPT { flow in Price } port def PriceOPT { flow out Price } port def LEDIPT { flow in LED } port def LEDOPT { flow out LED } port def TicketIPT { flow in Tickect } port def TicketOPT { flow out Tickect } port def StatusIPT { flow in Int } port def StatusOPT { flow out Int } port def LicensePlateIPT { flow in String } port def LicensePlateOPT { flow out String } port def VehicleIPT { flow in Vehicle } port def VehicleOPT { flow out Vehicle } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def QuantifyIPT { flow in Int } port def QuantifyOPT { flow out Int } port def PresenceIPT { flow in Boolean } port def PresenceOPT { flow out Boolean } port def CodeIPT { flow in Int } port def SpotIPT { flow in Spot } port def SpotOPT { flow in Spot } port def PaymentMadeIPT { flow in Boolean } port def PaymentMadeOPT { flow out Boolean } port def FiscalNoteIPT { flow in FiscalNote } port def ResponseLicensePlateCPT { ports : query : CommandIPT ; answer : LicensePlateOPT ; } port def RequestLicensePlateCPT { ports : query : CommandOPT ; answer : LicensePlateIPT ; } port def StatusTicketCPT { ports : ticket : TicketIPT ; status : StatusOPT ; } }