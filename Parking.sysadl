Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } dimension PriceDimension dimension ColorDimension unit Real { dimension = PriceDimension } unit Red { dimension = ColorDimension } unit Green { dimension = ColorDimension } unit Blue { dimension = ColorDimension } datatype Vehicle { attributes : driver : String ; licensePlate : String ; } datatype Tickect { attributes : entranceTime : DateTime ; validateTime : DateTime ; barCode : String ; helpText : String ; exitTime : DateTime ; vehicle : Vehicle ; } datatype FiscalNote { attributes : ticket : Tickect ; costPrice : Price ; payedPrice : Price ; adress : String ; paymentType : PaymentType ; } value type DateTime { } value type Price { unit = Real dimension = PriceDimension } value type Color { dimension = ColorDimension } value type RedColor extends Color { unit = Red dimension = ColorDimension } value type GreenColor extends Color { unit = Green dimension = ColorDimension } value type BlueColor extends Color { unit = Blue dimension = ColorDimension } enum Command { ON , OFF } enum PaymentType { DEBIT , CREDIT , PIX , CASH } } Requirement VerPrecosRF ( 1.1 ) { text = "\"O sistema deverá fornecer na entrada a visualização dos valores do estacionamento pelo tempo de permanência.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement VisualizarCapacidadeRF ( 1.3 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de visualizar a disponibilidade de vagas do estacionamento na entrada.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement CalcularTaxaRF ( 1.6 ) { text = "\"O sistema deverá calcular a taxa de estacionamento do veículo no momento de pagamento de ticket.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF.RealizarPagamentoRF ; } Requirement EmitirReciboRF ( 1.7 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de emitir recibo de pagamento.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF.RealizarPagamentoRF ; } Requirement ChaveMestreRF ( 1.9 ) { text = "\"O sistema deverá fornecer para o operador a capacidade de liberar cancela com cartão mestre.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement Configuracoes ( 1.10 ) { text = "\"O sistema deverá fornecer para o administrador a capacidade de definir configurações sobre o estacionamento.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement DetectarOcupacaoRF ( 1.11 ) { text = "\"O sistema deverá detectar a ocupação de uma vaga automaticamente.\"" derive VisualizarCapacidadeRF ; } Requirement GerarRelatorioRF ( 1.12 ) { text = "\"O sistema deve ser capaz de gerar relatórios de uso, incluindo estatísticas de ocupação, horários de pico e receitas.\"" derive SistemaEstacionamentoRequisitos.SistemaEstacionamentoRF ; } Requirement SistemaEstacionamentoRequisitos ( 0 ) { text = "\"O sistema deve satisfazer os requisitos funcionais e não funcionais”." Requirement SistemaEstacionamentoRF ( 1 ) { text = "“O sistema deve ser capaz de gerenciar a entrada e saída de veículos do estacionamento”." Requirement DeixarEstacionamentoRF ( 1.8 ) { text = "\"O sistema deverá abrir cancela de saída automaticamente se o veículo em circunstância estiver com ticket validado.\"" } Requirement RealizarPagamentoRF ( 1.5 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de realizar o pagamento de ticket.\"" } Requirement RegistrarVeiculoRF ( 1.2 ) { text = "\"O sistema deverá registrar o veículo na entrada do estacionamento.\"" Requirement EmitirTicketRF ( 1.4 ) { text = "\"O sistema deverá fornecer para o cliente a capacidade de emitir ticket na entrada do estacionamento.\"" } } } Requirement QualidadeRNF ( 2 ) { text = "“O sistema deve satisfazer o desempenho, segurança, conformidade, escalabilidade, usabilidade, tolerância a falhas e disponibilidade”." Requirement DesempenhoRNF ( 2.1 ) { text = "\"O sistema deverá ser capaz de processar uma entrada/saída de veículo em menos de 5  segundos.\"" } Requirement DesempenhoRNF ( 2.2 ) { text = "\"O tempo de espera na fila da entrada/saída não deve exceder 10 minutos, inclusive durante horários de pico.\"" } Requirement DisponibilidadeRNF ( 2.4 ) { text = "\"O sistema de controle de entradas/saídas deverá estar disponível 99% do tempo e haver redundância para caso de falhas.\"" } Requirement SegurancaRNF ( 2.3 ) { text = "\"O sistema deverá ser capaz de garantir a proteção dos dados dos clientes e das transações financeiras.\"" } Requirement EscalabilidadeRNF ( 2.6 ) { text = "\"O sistema deverá ser capaz de escalar horizontalmente para acomodar o aumento na demanda, como durante eventos especiais.\"" } Requirement UsabilidadeRNF ( 2.7 ) { text = "\"O sistema deverá ser fácil de usar para os operadores e clientes, com interface intuitiva.\"" } Requirement ToleranciaRNF ( 2.9 ) { text = "\"O sistema deverá ser projetado para tolerar falhas de hardware ou software sem interrupções significativas no serviço.\"" } Requirement ConformidadeRNF ( 2.10 ) { text = "\"O sistema deverá estar em conformidade com todas as regulamentações locais, estaduais e nacionais relacionadas a estacionamentos pagos, privacidade de dados e segurança.\"" } } } Requirement DisponibilidadeRNF ( 2.5 ) { text = "\"O tempo de inatividade planejado para manutenção não deverá afetar as operações durante o horário de funcionamento do estacionamento.\"" derive SistemaEstacionamentoRequisitos.QualidadeRNF.DisponibilidadeRNF ; } Requirement UsabilidadeRNF ( 2.8 ) { text = "\"Os avisos e instruções devem ser claros e compreensíveis.\"" derive SistemaEstacionamentoRequisitos.QualidadeRNF.UsabilidadeRNF ; } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def CaptureLincesePlateCN { participants : ~ source : LicensePlateOPT ; ~ target : LicensePlateIPT ; flows : String from source to target } connector def DetectPresenceCN { participants : ~ source : PresenceOPT ; ~ target : PresenceIPT ; flows : Boolean from source to target } connector def EmitColorCN { participants : ~ source : ColorOPT ; ~ target : ColorIPT ; flows : Color from source to target } connector def SendTicketCN { participants : ~ source : TicketOPT ; ~ target : TicketIPT ; flows : Tickect from source to target } connector def SendCommandCN { participants : ~ source : CommandOPT ; ~ target : CommandIPT ; flows : Command from source to target } connector def SendQuantityCN { participants : ~ source : QuantifyOPT ; ~ target : QuantifyIPT ; flows : Int from source to target } connector def SendVehicle { participants : ~ source : VehicleOPT ; ~ target : VehicleIPT ; flows : Vehicle from source to target } connector def SendStatusCN { participants : ~ source : StatusOPT ; ~ target : StatusIPT ; flows : Int from source to target } } package ParkingSystemComponents { import SysADL.types ; import ParkingSystemConnectors ; import ParkingSystemPorts ;
	component def ParkingSystem { configuration { components : EntranceInterfaceCP : EntranceInterfaceCP { using ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; } ExitInterfaceCP : ExitInterfaceCP { using ports : validated : TicketOPT ; } TicketControllerCP : TicketControllerCP { using ports : newTicket : TicketOPT ; newPlate : LicensePlateIPT ; newVehicle : VehicleIPT ; } ParkingControllerCP : ParkingControllerCP { using ports : ticket : TicketIPT ; gate : CommandOPT ; newStatus : StatusOPT ; } MonitorExitControllerCP : MonitorExitControllerCP { using ports : read : LicensePlateIPT ; processed : TicketOPT ; } ExitCameraCP : CameraCP { using ports : detected : LicensePlateOPT ; } GateCP : GateCP { using ports : state : CommandIPT ; } EntranceCameraCP : CameraCP { using ports : plate : LicensePlateOPT ; } ParkingInterfaceCP : ParkingInterfaceCP { using ports : displayStatus : StatusIPT ; displayQuantify : QuantifyIPT ; } SpotControllerCP : SpotControllerCP { using ports : newQuantify : QuantifyOPT ; status : ColorOPT ; occupation : PresenceIPT ; } VacancySensorCP : PresenceSensorCP { using ports : reading : PresenceOPT ; } LEDCP : LEDCP { using ports : displayColor : ColorIPT ; } connectors : p2 : CaptureLincesePlateCN bindings detected = read ; v1 : SendVehicle bindings vehicle = newVehicle ; t2 : SendTicketCN bindings validated = ticket ; t3 : SendTicketCN bindings processed = ticket ; t1 : SendTicketCN bindings newTicket = ticket ; c1 : SendCommandCN bindings gate = state ; p1 : CaptureLincesePlateCN bindings plate = newPlate ; s1 : SendStatusCN bindings newStatus = displayStatus ; q1 : SendQuantityCN bindings newQuantify = displayQuantify ; d1 : DetectPresenceCN bindings reading = occupation ; l1 : EmitColorCN bindings status = displayColor ; } } boundary
	component def ExitInterfaceCP { ports : ticket : TicketOPT ; }
	component def CameraCP { ports : vehicle : LicensePlateOPT ; }
	component def TicketControllerCP { ports : newTicket : TicketOPT ; plate : LicensePlateIPT ; vehicle : VehicleIPT ; }
	component def GateCP { ports : state : CommandIPT ; }
	component def PresenceSensorCP { ports : detected : PresenceOPT ; }
	component def LEDCP { ports : display : ColorIPT ; }
	component def SpotControllerCP { ports : quantify : QuantifyOPT ; status : ColorOPT ; detected : PresenceIPT ; }
	component def ParkingControllerCP { ports : ticket : TicketIPT ; gate : CommandOPT ; satus : StatusOPT ; } boundary
	component def EntranceInterfaceCP { ports : driver : ButtonPressIPT ; vehicle : VehicleOPT ; }
	component def ParkingInterfaceCP { ports : status : StatusIPT ; quantify : QuantifyIPT ; }
	component def MonitorExitControllerCP { ports : plate : LicensePlateIPT ; ticket : TicketOPT ; }
	component def PaymentControllerCP { ports : voucher : FiscalNoteOPT ; ticket : TicketIPT ; payment : PaymentMadeIPT ; }
	component def PaymentInterfaceCP { ports : mode : PaymentMadeOPT ; ticket : TicketOPT ; } } package ParkingSystemPorts { import SysADL.types ; port def ButtonPressIPT { flow in Boolean } port def FiscalNoteOPT { flow out FiscalNote } port def PriceIPT { flow in Price } port def PriceOPT { flow out Price } port def ColorIPT { flow in Color } port def ColorOPT { flow out Color } port def TicketIPT { flow in Tickect } port def TicketOPT { flow out Tickect } port def StatusIPT { flow in Int } port def StatusOPT { flow out Int } port def LicensePlateIPT { flow in String } port def LicensePlateOPT { flow out String } port def VehicleIPT { flow in Vehicle } port def VehicleOPT { flow out Vehicle } port def CommandIPT { flow in Command } port def CommandOPT { flow out Command } port def QuantifyIPT { flow in Int } port def QuantifyOPT { flow out Int } port def PresenceIPT { flow in Boolean } port def PresenceOPT { flow out Boolean } port def TicketValidadedIPT { flow in Boolean } port def TicketValidatedOPT { flow out Boolean } port def OpenSignalIPT { flow in Boolean } port def OpenSignalOPT { flow out Boolean } port def PaymentMadeIPT { flow in Boolean } port def PaymentMadeOPT { flow out Boolean } port def CloseSignalIPT { flow in Boolean } port def CloseSignalOPT { flow out Boolean } }